#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Functions for reading the VTK files generated by Palabos.
"""

# native modules
import os
import errno
import functools

# third-party modules
import torch
import vtk
from vtk.util import numpy_support as vn

# local modules
##none##
 

class VTKLoader():
    """ Class with functions that load vtk files and convert to tensor.
    
    Each channel is a physical quantity.
    
    ----------
    ARGUMENTS
        
        channels: list with the strings with the names of
                  the fields that will be read
        nx, ny, nz: simulation dimensions
        
    """
    def __init__(self, channels, nx=0, ny=0, nz=0):
        
        
        self.nx, self.ny, self.nz = nx, ny, nz        
        self.N = nx*ny*nz
        
        # list with the functions to read the files
        self.read_fun = []
        
        # define the functions here, only once, that will select
        # the channels to be readed!
        for field in channels:
            if field == 'density':
                self.read_fun.append(
                    functools.partial(self.read_scalar,
                                      name='density'))
            elif field == 'velocity-x':
                self.read_fun.append(
                    functools.partial(self.read_vector,
                                      name='velocity',
                                      direction=0))
            elif field == 'velocity-y':
                self.read_fun.append(
                    functools.partial(self.read_vector,
                                      name='velocity',
                                      direction=1))
            else:
                raise NameError(
                    f"Unknown channel name ('{field}'). Implementation necessary.") 
          
    
        
    def read_scalar(self, image_points, name):
        """ Reads scalar field and returns tensor.
        
        ----------
        ARGUMENTS

            image_points: vtkPointData object of the file
            name: string with the name of the scalar field

        ----------    
        RETURNS

            tensor: tensor in format (nz, nx, ny)
        
        """
        
        vtk_array = image_points.GetArray(name)
        np_array = vn.vtk_to_numpy(vtk_array).reshape(
            self.nx, self.ny, self.nz)
        
        # flip channel dimension
        tensor = torch.from_numpy(np_array).permute(2,0,1)
        
        return tensor
    

    
    def read_vector(self, image_points, name, direction):
        """ Reads vector field and returns tensor.
        
        ----------
        ARGUMENTS

            image_points: vtkPointData object of the file
            name: string with the name of the vector field
            direction: direction to be read (0, 1 or 2)

        ----------    
        RETURNS

            tensor: tensor in format (nz, nx, ny)   
        
        """
        
        vtk_array = image_points.GetArray(name)
        dir_vtk_array = vtk.vtkDoubleArray()
        dir_vtk_array.SetNumberOfTuples(self.N)
        
        # copy components of given direction
        dir_vtk_array.CopyComponent(0, vtk_array, direction)
        np_array = vn.vtk_to_numpy(dir_vtk_array).reshape(
            self.nx, self.ny, self.nz)
        
        # flip channel dimension
        tensor = torch.from_numpy(np_array).permute(2,0,1)
        
        return tensor
    
    
    
    def load2D(self, fname):
        """ Reading 2D fields from vtk files
        
        ----------
        ARGUMENTS

            fname: vtk file patch

        ----------    
        RETURNS

            data: tensor with the selected fields, format
                  (channel, nx, ny)
            nx, ny: array dimensions

        """

        # check file existence
        if not os.path.isfile(fname):
            raise FileNotFoundError(
                errno.ENOENT,os.strerror(errno.ENOENT), fname)
        
        reader = vtk.vtkXMLImageDataReader()
        reader.SetFileName(fname)
        reader.Update()

        # if the dimensions are not knwown
        if self.nx * self.ny * self.nz == 0:
            extent = reader.GetOutput().GetExtent()
            self.nx = extent[1] + 1
            self.ny = extent[3] + 1
            self.nz = extent[5] + 1
            self.N = self.nx*self.ny*self.nz

        image_points = reader.GetOutput().GetPointData()

        # reading fields
        tensors = [field_fun(image_points) for 
                       field_fun in self.read_fun]
        # concatenate channels
        data = torch.cat(tensors, dim=0, out=None)
        return data, self.nx, self.ny
    
    
    
    def load3D(self, fname):
        """ Reading 3D fields from vtk files
        TO IMPLEMENT!
        
        ----------
        ARGUMENTS

            fname: filename

        ----------    
        RETURNS

            data: tensor with the density and velocity fields, format
                  (channel, nx, ny) - channel is always 3
                  TO IMPLEMENT: 3D capability!
            nx, ny, nz: array dimensions

        """

        pass
    
